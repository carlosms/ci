# Default shell
SHELL := /bin/bash

# Package configuration
PROJECT ?=
COMMANDS ?=
DEPENDENCIES ?=
PRERUN ?=
POSTRUN ?=
GOFLAGS ?=

# Dockerfiles to be build, list of pairs file/name, example `Dockerfile:my-image`
DOCKERFILES ?= Dockerfile:$(PROJECT)
# Docker registry to push the docker image.
DOCKER_REGISTRY ?= docker.io
# Docker organization to be used at the docker image name.
DOCKER_ORG ?= src-d
# Username name used to login on the docker registry.
DOCKER_USERNAME ?=
# Password used to login on the docker registry.
DOCKER_PASSWORD ?=
# When `make docker-push` if non-empty also push the latest tag.
DOCKER_PUSH_LATEST ?=
# Docker OS/Arch used to match the right binaries.
DOCKER_OS ?= $(shell docker version -f "{{.Server.Os}}")
DOCKER_ARCH ?= $(shell docker version -f "{{.Server.Arch}}")

# Checking mandatory variables
ifndef PROJECT
$(error ERROR! The PROJECT variable cannot be empty)
endif

# Environment
WORKDIR := $(PWD)
BUILD_PATH := $(WORKDIR)/build
BIN_PATH := $(BUILD_PATH)/bin
BRANCH ?= $(shell git rev-parse --abbrev-ref HEAD)

# Build information
BUILD ?= $(shell date +"%m-%d-%Y_%H_%M_%S")
COMMIT ?= $(shell git rev-parse HEAD | cut -c1-7)
GIT_DIRTY = $(shell test -n "`git status --porcelain`" && echo "-dirty" || true)
DEV_PREFIX := dev
VERSION ?= $(DEV_PREFIX)-$(COMMIT)$(GIT_DIRTY)

# Travis CI
ifneq ($(origin CI), undefined)
	WORKDIR := $(TRAVIS_BUILD_DIR)
	BUILD_PATH := $(WORKDIR)/build
	VERSION := $(TRAVIS_BRANCH)
endif

# Packages content
PKG_OS ?= darwin linux
PKG_ARCH = amd64

# Go parameters
GOCMD = go
GOBUILD = $(GOCMD) build $(GOFLAGS)
GOCLEAN = $(GOCMD) clean
GOINSTALL = $(GOCMD) install -v $(GOFLAGS)
GOGET = $(GOCMD) get -v -t
GOTEST = $(GOCMD) test -v $(GOFLAGS)
GOTEST_RACE = $(GOCMD) test -v -race $(GOFLAGS)
CGO_ENABLED ?= 0

# Coverage
COVERAGE_REPORT = coverage.txt
COVERAGE_PROFILE = profile.out
COVERAGE_MODE = atomic

PACKAGES = $(shell go list ./... | grep -v '/vendor/')

# Rules

.PHONY: $(DEPENDENCIES) $(PACKAGES) $(COMMANDS) dependencies docker-push docker-push-latest packages test test-coverage pre-run post-run clean

dependencies: $(DEPENDENCIES)
	$(GOGET) -t ./...; \

$(DEPENDENCIES):
	$(GOGET) $@/...

docker-validate:
	@if [ -z "$(DOCKER_USERNAME)" ]; then \
		echo "DOCKER_USERNAME variable cannot be empty."; \
		exit 1; \
	fi; \
	if [ -z "$(DOCKER_PASSWORD)" ]; then \
		echo "DOCKER_PASSWORD variable cannot be empty."; \
		exit 1; \
	fi

docker-login: docker-validate
	@docker login -u "$(DOCKER_USERNAME)" -p "$(DOCKER_PASSWORD)" $(DOCKER_REGISTRY); \

docker-build: $(COMMANDS)
	@if [ -z "$(DOCKER_ORG)" ]; then \
		echo "DOCKER_ORG variable cannot be empty."; \
		exit 1; \
	fi; \
	for d in $(DOCKERFILES); do \
		dockerfile=`echo $${d} | cut -d":" -f 1`; \
		repository=`echo $${d} | cut -d":" -f 2`; \
		docker build -t $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION) -f $(WORKDIR)/$$dockerfile .; \
	done;

docker-push: docker-login docker-build
	@if [ "$(BRANCH)" == "master" ]; then \
		echo "docker-push is disabled on master branch" \
		exit 1; \
	fi; \
	for d in $(DOCKERFILES); do \
		dockerfile=`echo $${d} | cut -d":" -f 1`; \
		repository=`echo $${d} | cut -d":" -f 2`; \
		docker push $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION); \
		if [ -n "$(DOCKER_PUSH_LATEST)" ]; then \
		 	docker tag $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:$(VERSION) \
				$(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:latest; \
			docker push $(DOCKER_REGISTRY)/$(DOCKER_ORG)/$${repository}:latest; \
		fi; \
	done;

packages: | packages-compile packages-compress
packages-compile: $(COMMANDS)

$(COMMANDS):
	@cd $(WORKDIR)/$@; \
	for os in $(PKG_OS); do \
		for arch in $(PKG_ARCH); do \
			mkdir -p $(BUILD_PATH)/$(PROJECT)_$${os}_$${arch}; \
			CGO_ENABLED=$(CGO_ENABLED) GOOS=$${os} GOARCH=$${arch} \
			$(GOBUILD) \
				-ldflags "-X main.version=$(VERSION) -X main.build=$(BUILD) -X main.commit=$(COMMIT)" \
				-o "$(BUILD_PATH)/$(PROJECT)_$${os}_$${arch}/`basename $@`" \
				.; \
			if [ "$(DOCKER_OS)" == "$${os}" ] && [ "$(DOCKER_ARCH)" == "$${arch}" ]; then \
				echo "Linking matching OS/Arch binaries to `build/bin` folder"; \
				cp -rf $(BUILD_PATH)/$(PROJECT)_$${os}_$${arch} $(BIN_PATH); \
			fi; \
		done; \
	done

packages-compress:
	@cd $(BUILD_PATH); \
	for os in $(PKG_OS); do \
		for arch in $(PKG_ARCH); do \
			tar -cvzf $(PROJECT)_$(VERSION)_$${os}_$${arch}.tar.gz $(PROJECT)_$${os}_$${arch}/; \
		done; \
	done

post-run:
	@for script in $(POSTRUN); do \
		$(WORKDIR)/$${script}; \
	done; \

pre-run:
	@for script in $(PRERUN); do \
		$(WORKDIR)/$${script}; \
	done; \

test:
	$(GOTEST) $(PACKAGES)

test-race:
	$(GOTEST_RACE) $(PACKAGES)

test-coverage:
	@cd $(WORKDIR); \
	echo "" > $(COVERAGE_REPORT); \
	for dir in $(PACKAGES); do \
		$(GOTEST) $$dir -coverprofile=$(COVERAGE_PROFILE) -covermode=$(COVERAGE_MODE); \
		if [ -f $(COVERAGE_PROFILE) ]; then \
			cat $(COVERAGE_PROFILE) >> $(COVERAGE_REPORT); \
			rm $(COVERAGE_PROFILE); \
		fi; \
	done || exit 1; \

codecov:
	@if [ ! -f $(COVERAGE_REPORT) ]; then \
		echo "Unable to find '$(COVERAGE_REPORT)', execute 'make test-coverage' first."; \
		exit 1; \
	fi; \
	if [[ ! -z "$(CODECOV_TOKEN)" ]] ; then \
		args="-t $(CODECOV_TOKEN)"; \
	fi; \
	bash <(curl -s https://codecov.io/bash) $${args};

# This target checks if files in a repository have changed after code generation
# how to generate files is up to project
#
# Example:
#
# validate-commit: generate-assets no-changes-in-commit
#
# generate-assets:
#    yarn build
#    go-bindata dist
no-changes-in-commit:
	git status --untracked-files=no --porcelain | grep -qe '..*'; \
	if  [ $$? -eq 0 ] ; then \
		git diff|cat; \
		echo >&2 "generated assets are out of sync"; \
		exit 2; \
	fi

clean:
	rm -rf $(BUILD_PATH) $(BIN_PATH) $(VENDOR_PATH)
	$(GOCLEAN) .
